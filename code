///////////////////////////// Définiion des variables ///////////////////////
funcprot(0);
r = 0;
t = 1;
// Nombre de modèles mélangés :
p = 2;
M = 100;
// Valeurs du sous jacent (l'actif) :
lbd = [100, 100];
S0 = 100;

// Valeurs des écarts types sur un an dans le modèle de Black Scholes :
// (Les volatilités)
sg = [0.2, 0.4];


// Probabilité de la variable aléatoire N :
p1 = 1/2;
p2 = 1-p1;
p_n = [p1, p2];

// Simulation d'une loi Gaussienne centrée réduite :
G = grand(1, p, 'nor', 0, 1);

// Tirage aléatoire d'une variable booléenne avec probabilité p :
function n_valeur=N()
    alpha = grand(1,1, 'def');
    if alpha>=p1 then n_valeur=1
    else 
       n_valeur=0
    end
endfunction

// Création de la liste des strikes K_k:
K = zeros(1,M+1);
K(1,1)=50;
for i=2:M+1
    K(1,i)= K(1,i-1)+1;
end



// Création de la fonction pour le calcul des Payoffs :
function phi_k=payoff(x,k,s)
    if s=="P" then phi_k = max(0, -x+K(1,1+k))
    else  
        phi_k = max(0, x-K(1,1+k))
    end
endfunction


// Densité de la loi normale :
mu = 0;
sigma = 1;
function resultat=fct_normale(x)
    resultat = cdfnor("PQ", x, mu, sigma);
endfunction

// Formation de l'actif
X = 0
for i=1:p
    X = X + N()*lbd(i)*exp(sg(i)*G(i));
end
disp(X);

// Variables pour la formule de Black-Scholes des Payoffs :
d1 = zeros(M+1, p);
d2 = zeros(M+1, p);

for i=1:p
    for j=1:M+1   
        d1(j, i) = (log(S0/K(1, j))+(r+0.5*sg(i)**2)*t)/(sg(i)*sqrt(t));
        d2(j, i) = d1(j, i) - sg(i)*sqrt(t);
    end
end

// Prix d'un call : (alpha_k d'un Call)
C = zeros(1, M+1);
for i=1:M+1
    C = sum(S0*fct_normale(d1(i, 1)) - K(1,i)*exp(-r*t)*fct_normale(d2(i, 1)), 2);
end

disp("Prix Call :");
disp(C);

// Prix d'un Put : (alpha_k d'un Put)
P = zeros(1, M+1);
for i=1:M+1
    P = sum(-S0*fct_normale(-d1(i, 1)) + K(1,i)*exp(-r*t)*fct_normale(-d2(i, 1)), 2);
end

disp("Prix Put : ");
disp(P);

// Maitenant que l'on a les valeurs des alpha_k, on va essayer de retrouver nos
// conditions initiales lambda, sigma, p

// Définition du paramètre beta à retrouver :
Beta = zeros(1, 3*p);

for i=1:p
    Beta(1,i)= lbd(i);
    Beta(1,i+p)= sg(i);
    Beta(1,i+2*p)= p_n(i);
end

disp("Beta = ");
disp(Beta);


// Optimisation en minimisant les résidus des moindres carrés :

// Définition des fonctions de payoff à présent inconnues :


























/////////////////////////////////////////////////////////////////////////////
// Mouvement Brownien
mu = 0;
T = 54;
vect_temps = zeros(1, T);
for i=1:T
	vect_temps(i)=i
end

sigma_b = t;
function resultat=fct_normale(x)
    resultat = cdfnor("PQ", x, mu, sigma_b);
endfunction

1
