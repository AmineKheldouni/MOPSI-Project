///////////////////////////// Définiion des variables ///////////////////////
funcprot(0);
r = 0;
t = 1;
// Nombre de modèles mélangés :
p = 2;
M = 100;
// Valeurs du sous jacent (l'actif) :
lbd = [100, 100];


// Valeurs des écarts types sur un an dans le modèle de Black Scholes :
// (Les volatilités)
sg = [0.2, 0.4];


// Probabilité de la variable aléatoire N :
p1 = 1/2;
p2 = 1-p1;
p_n = [p1, p2];

// Simulation d'une loi Gaussienne centrée réduite :
G = grand(1, p, 'nor', 0, 1);

// Put ou Call 
type_operation = "C"

// Tirage aléatoire d'une variable uniforme avec probabilité p_n :
function n_valeur=N()
    alpha = grand(1,p, 'def');
    for i=1:p
        if alpha(i)== max(alpha) then n_valeur= i
        end
    end
endfunction

// Définition du paramètre beta à retrouver :
Beta_opt = zeros(1, 3*p);

for i=1:p
    Beta_opt(1,i)= lbd(i);
    Beta_opt(1,i+p)= sg(i);
    Beta_opt(1,i+2*p)= p_n(i);
end


S0 = 0
for i=1:p
    S0 = S0 + N()*Beta_opt(i)*exp(Beta_opt(i+p)*G(i));
end
    
// Création de la liste des strikes K_k:
K = zeros(1,M+1);
K(1,1)=50;
for i=2:M+1
    K(1,i)= K(1,i-1)+1;
end



// Création de la fonction pour le calcul des Payoffs :
function phi_k=payoff(x,k,s)
    if s=="P" then phi_k = max(0, -x+K(1,1+k))
    else  
        phi_k = max(0, x-K(1,1+k))
    end
endfunction


// Densité de la loi normale :
mu = 0;
sigma = 1;
function resultat=fct_normale(x)
    resultat = cdfnor("PQ", x, mu, sigma);
endfunction

// Formation de l'actif
X = 0
for i=1:p
    X = X + N()*lbd(i)*exp(sg(i)*G(i));
end


// Variables pour la formule de Black-Scholes des Payoffs :
d1 = zeros(M+1, p);
d2 = zeros(M+1, p);

for i=1:p
    for j=1:M+1   
        d1(j, i) = (log(S0/K(1, j))+(r+0.5*sg(i)**2)*t)/(sg(i)*sqrt(t));
        d2(j, i) = d1(j, i) - sg(i)*sqrt(t);
    end
end

// Prix d'un call : (alpha_k d'un Call)
C = zeros(1, M+1);
for i=1:M+1
    C(1, i) = sum(S0*fct_normale(d1(i, 1)) - K(1,i)*exp(-r*t)*fct_normale(d2(i, 1)), 2);
end

clf();
subplot(121);
plot(K, C);
xtitle("Call Price versus Strike K")

// Prix d'un Put : (alpha_k d'un Put)
P = zeros(1, M+1);
for i=1:M+1
    P(1, i) = sum(-S0*fct_normale(-d1(i, 1)) + K(1,i)*exp(-r*t)*fct_normale(-d2(i, 1)), 2);
end



subplot(122);
plot(K, P);
xtitle("Put Price versus Strike K")

// Maitenant que l'on a les valeurs des alpha_k, on va essayer de retrouver nos
// conditions initiales lambda, sigma, p


// Optimisation en minimisant les résidus des moindres carrés :

// Définition des fonctions de payoff à présent inconnues :

function valeur=residus(Beta) 
    //A Beta connu, renvoit Somme sur les strikes de (E(phi_k)-alpha_k)**2
    // Calcul de S0 :
    Beta(3*p) = 1-sum(Beta(2*p+1:3*p-1))
        S0 = 0
        for i=1:p
            S0 = S0 + N()*Beta(i)*exp(Beta(i+p)*G(i));
        end
        if S0 == 0 then valeur = 100000000000000
        else
    // Calcul de d1 & d2 :    
            d1 = zeros(M+1, p);
            d2 = zeros(M+1, p);
            for i=1:p
                for j=1:M+1
                d1(j, i) = (log(S0/K(1, j))+(r+0.5*Beta(1, i+p).^2)*t)/(Beta(1, i+p)*sqrt(t));
                d2(j, i) = d1(j, i) - Beta(1, i+p)*sqrt(t);
              end
            end
        if type_operation == "C" then
            C_fct = zeros(1,M+1)
            for i=1:M+1
                C_fct(1, i) = sum(S0*fct_normale(d1(i, 1)) - K(1,i)*exp(-r*t)*fct_normale(d2(i, 1)), 2);
            end
            
            valeur = sum((C_fct-C).^2);
        else
            P_fct = zeros(1,M+1)
            for i=1:M+1
                P_fct(1, i) = sum(-S0*fct_normale(-d1(i, 1)) + K(1,i)*exp(-r*t)*fct_normale(-d2(i, 1)), 2);
            end
            valeur = sum((P_fct-P).^2); 
        end

    end
endfunction

disp(residus(Beta_opt))

function [f_val, derf_val, ind]=fct_objective(Beta, ind)
    f_val = residus(Beta)
    eps = zeros(1, 3*p)
    for i=1:3*p
        eps(1,i) = 0.0001
    end
    derf_val = (residus(Beta+eps)-residus(Beta))/norm(eps)
endfunction

Beta0 = [50, 50, 0.1, 0.1, 0.3, 0.7]
[fopt, xopt] = optim(fct_objective, Beta_opt, "gc")

disp(xopt)






















/////////////////////////////////////////////////////////////////////////////
// Mouvement Brownien
mu = 0;
T = 54;
vect_temps = zeros(1, T);
for i=1:T
	vect_temps(i)=i
end

sigma_b = t;
function resultat=fct_normale(x)
    resultat = cdfnor("PQ", x, mu, sigma_b);
endfunction

1
